global:
  labels:
    cluster: tigerbeetle

defaultPodOptions:
  automountServiceAccountToken: false
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                cluster: tigerbeetle
            topologyKey: kubernetes.io/hostname
      # TigerBeetle typically runs as root, so we won't set runAsUser/Group here
      # unless specific non-root user requirements are identified.

controllers:
  main:
    type: statefulset
    pod:
      securityContext:
        seccompProfile:
          type: Unconfined
    serviceAccount:
      identifier: main
    replicas: 3 # In the current version of TigerBeetle, cluster size can not be changed after creation, but this limitation will be lifted in the future.
    initContainers:
      resolve-addresses:
        image:
          repository: bitnami/kubectl
          tag: "1.33"
        env:
          RESOLVE_TIMEOUT_SECS: "90"
          SLEEP_SECS: "3"
          NS:
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
        command: [ "/bin/sh","-c" ]
        args:
          - |
            set -eu
            : "${NS:?}"; : "${SVC:?}"
            RESOLVE_TIMEOUT_SECS="${RESOLVE_TIMEOUT_SECS:-60}"
            SLEEP_SECS="${SLEEP_SECS:-2}"
            PORT="${PORT:-}"
            PORT_NAME="${PORT_NAME:-}"
            IP_FAMILY="${IP_FAMILY:-}"
            
            # If a PORT_NAME is given, fetch its numeric port from the Service
            if [ -z "$PORT" ] && [ -n "$PORT_NAME" ]; then
              PORT="$(kubectl -n "$NS" get svc "$SVC" -o jsonpath="{.spec.ports[?(@.name=='$PORT_NAME')].port}" || true)"
            fi
            [ -n "$PORT" ] || { echo "ERROR: no PORT or PORT_NAME resolved"; exit 1; }
            
            end=$(( $(date +%s) + RESOLVE_TIMEOUT_SECS ))
            while [ "$(date +%s)" -lt "$end" ]; do
              # Try classic Endpoints first (ready + notReady)
              IPS="$(kubectl -n "$NS" get endpoints "$SVC" -o jsonpath='{range .subsets[*].addresses[*]}{.ip}{"\n"}{end}{range .subsets[*].notReadyAddresses[*]}{.ip}{"\n"}{end}' 2>/dev/null || true)"
            
              # Fall back to EndpointSlices
              if [ -z "$IPS" ]; then
                IPS="$(kubectl -n "$NS" get endpointslices -l "kubernetes.io/service-name=$SVC" \
                      -o jsonpath='{range .items[*].endpoints[*].addresses[*]}{.}{"\n"}{end}' 2>/dev/null || true)"
              fi
            
              # Normalize, unique, optional family filter
              IPS="$(printf '%s\n' "$IPS" | sed '/^$/d' | sort -u)"
              if [ "$IP_FAMILY" = "ipv4" ]; then
                IPS="$(printf '%s\n' "$IPS" | grep -E '^[0-9.]+$' || true)"
              elif [ "$IP_FAMILY" = "ipv6" ]; then
                IPS="$(printf '%s\n' "$IPS" | grep -E '^[0-9a-fA-F:]+$' || true)"
              fi
            
              if [ -n "$IPS" ]; then
                OUT="$(printf '%s\n' "$IPS" | awk -v p="$PORT" 'BEGIN{ORS=""; c=0} NF{if(c++){printf ","}; printf $0 ":" p}')"
                echo "$OUT" > /work/addresses.txt
                echo "Resolved (API): $OUT"
                exit 0
              fi
              sleep "$SLEEP_SECS"
            done
            
            echo "ERROR: no endpoints found for Service '$SVC' in namespace '$NS'" >&2
            exit 1

      format:
        image:
          repository: ghcr.io/tigerbeetle/tigerbeetle
          tag: "{{ .Chart.AppVersion }}"
        imagePullPolicy: IfNotPresent
        command: [ "/bin/sh","-c" ]
        
        securityContext:
          runAsNonRoot: true
          runAsUser: 10001
          allowPrivilegeEscalation: false
          capabilities:
            add: [ "IPC_LOCK" ]
        
        args:
          - |
            set -xeuo pipefail
            REPLICA_INDEX="${HOSTNAME##*-}"
            if [ -f "/data/data.tigerbeetle" ]; then
              echo "Data file already exists, skipping format."
              exit 0
            fi
            
            echo "Formatting data file for replica index ${REPLICA_INDEX}"
            /tigerbeetle format \
              --log-debug \
              --cluster="${CLUSTER_ID}" \
              --replica-count="${REPLICA_COUNT}" \
              --replica="${REPLICA_INDEX}" \
              "/data/data.tigerbeetle"
        envFrom:
          - configMapRef:
              identifier: config
          - secretRef:
              identifier: config
    containers:
      main:
        image:
          repository: ghcr.io/tigerbeetle/tigerbeetle
          tag: "{{ .Chart.AppVersion }}"
        
        args:
          - start
          - --addresses=$(cat /work/addresses.txt)
          - /data/data.tigerbeetle
        
        securityContext:
          runAsNonRoot: true
          runAsUser: 10001
          allowPrivilegeEscalation: false
          capabilities:
            add: [ "IPC_LOCK" ]
    statefulset:
      podManagementPolicy: Parallel
      volumeClaimTemplates:
        - name: data
          mountPath: /data
          accessMode: "ReadWriteOnce"
          size: 1Gi
          storageClass: "" # Use default storage class or specify one

service:
  main:
    controller: main
    type: ClusterIP
    ports:
      http:
        port: 3000
        targetPort: 3000
        protocol: TCP
  headless:
    controller: main
    type: ClusterIP
    clusterIP: None
    publishNotReadyAddresses: true
    ports:
      http:
        port: 3000
        targetPort: 3000
        protocol: TCP

secrets:
  config:
    enabled: true
    stringData:
      CLUSTER_ID: "some-cluster-id"

persistence:
  work:
    type: emptyDir
    advancedMounts:
      main:
        main:
          - path: /work/addresses.txt
            readOnly: true
            subPath: addresses.txt
        resolve-addresses:
          - path: /work

rbac:
  roles:
    endpointsReader:
      enabled: true
      type: Role
      rules:
        - apiGroups:
            - "discovery.k8s.io"
          resources:
            - "endpointslices"
          verbs:
            - "get"
            - "list"
            - "watch" # watch is optional; keep if you might stream changes
        - apiGroups:
            - ""
          resources:
            - "endpoints"
          verbs:
            - "get"
            - "list"
            - "watch"

  bindings:
    endpointsReaderBinding:
      enabled: true
      type: RoleBinding
      roleRef:
        identifier: endpointsReader         # refers to rbac.roles.endpointsReader above
      subjects:
        - kind: ServiceAccount
          identifier: main
          namespace: "{{ .Release.Namespace }}"

serviceAccount:
  main:
    enabled: true
    annotations: { }